# 6장. 도커 볼륨을 이용한 persistence storage

이번 장에서는 도커 볼륨과 바인드 마운트를 활용해 컨테이너가 죽더라도 데이터를 잃지 않는 방법에 대해 배워보았다. 일단 컨테이너는 자체적인 파일 시스템을 가진다. 같은 이미지에서 만들어진 컨테이너라도 독립적인 파일 시스템을 가진다는 의미이다. 간단하게 살펴보면 컨테이너의 파일 시스템은 이미지 레이어(읽기 전용) + 컨테이너별 기록 가능한 레이어 이렇게 나뉜다. 그런데 이미지 레이어는 여러 컨테이너가 공유해서 효율을 높인다. 기록 가능한 레이어는 이제 각 컨테이너에서 작성한 내용이 들어가는데 컨테이너가 잠시 멈춰도 사라지지 않는다. 근데 컨테이너가 아예 rm명령을 통해 삭제가 되면 저 내용은 날아가버린다! 이런 상황을 방지하기 위해서 컨테이너와 독립적인 저장소를 만들고 싶다는 생각이 든다. 이런 문제를 해결할 수 있는 두가지 방법이 있다.

### 도커 볼륨 Volume

볼륨은 이미지, 컨테이너와 같은 하나의 도커 객체이다. 이제 이 볼륨을 컨테이너의 특정 디렉토리와 연결하는 방식으로 컨테이너가 삭제되더라도 볼륨은 남아있기 때문에 다시 볼륨만 연결해주면 데이터를 잃지 않고 활용할 수 있다. 볼륨을 가장 많이 활용하는 경우는 서비스 업데이트를 통해 컨테이너를 교체해주어야하는데 이전 버전의 데이터를 그대로 가져와야하는 경우 볼륨만 연결해주면 그대로 가져갈 수 있다. 물론 단점도 있다.

종종 각 컨테이너가 자신만 접근할 수 있는 파일을 필요로하는데, 이런 경우에 다른 컨테이너가 동시에 접근하게 혀용하면 문제가 발생할 수도 있다.

볼륨을 사용하는 방법은 크게 2가지가 있다.

- Dockerfile에 Volume 인스트럭션 활용하기
  ```docker
  # Dockerfile
  # 아래와 같이 볼륨과 연결될 디렉토리를 컨테이너 안에 생성해준다
  Volume /data

  # 현재 컨테이너의 마운트 정보 확인하기
  # 아래 명령어를 통해 특정 컨테이너와 연결된 볼륨, 바인드 마운트 정보를 확인할 수 있다
  docker container inspect --format '{{.Mounts}}' [container name]

  # docker volume --help 명령어를 통해 각종 볼륨관련 명령어를 확인하자
  docker create volume myVolue
  docker volume ls
  ```
  나중에 해당 이미지로 컨테이너를 생성하면 자동으로 볼륨이 생성된다.
- Docker run 명령시 —volume, volumes-from 옵션 활용하기
  근데 위와 같이 활용하면 컨테이너 실행시 계속해서 새로운 볼륨이 생성되기 때문에 다른 이미지와 볼륨을 공유하려면 저 볼륨을 직접적으로 찾아줘야한다. 나중에 컨테이너가 없어지면 어떤 볼륨인지 찾을수가 없어서 문제가 생긴다. 그래서 Dockerfile에는 참고용으로 볼륨을 활용한다고 명시만 해두고, —volume 이나 —volumes-from 옵션을 통해 명시적으로 볼륨을 연결지어주는게 좋다. —volume은 볼륨을 넣어주면 되고, —volumes-from 옵션은 볼륨을 공유할 컨테이너를 명시해주면 된다.

요약하자면

1. 볼륨은 컨테이너 간 파일 공유보다는 업데이트 간 상태를 보존하기 위한 용도로 사용해야 한다
2. 이미지에서 정의하는 것보다는 명시적으로 관리하는 편이 더 낫다
3. 볼륨에 적절한 이름을 붙여서 생성하고, 업데이트 시 다른 컨테이너에 연결해주면 된다

참고로 Dockerfile에 Volume 명령을 통해 명시해놨어도 —volume 옵션을 통해 새로 지정해주면 지정한게 들어가고 새롭게 볼륨을 생성하지는 않는다.

## 도커 bind mount

볼륨보다 좀 더 직접적으로 호스트와 컨테이너 사이의 파일을 공유하는 방법이 있다. 바로 바인드 마운트를 활용하는 것이다. 개념적으로는 호스트의 모든 파일시스템과 컨테이너를 연결해줄 수 있다. 네트워크 상에 연결된 파일 시스템도 가능하지만 조금 복잡하고 어렵기 때문에 여기서는 (로컬) 바인드 마운트를 다룬다.

개념은 로컬의 디렉토리/파일을 컨테이너 내의 디렉토리/파일과 연결해주는 것이다. (진짜 파일시스템에서의 마운트 ㅇㅇ) 양 방향으로 공유가 쉽고 컨테이너가 호스트의 파일 시스템에 직접적으로 접근할 수 있기때문에 많은 일이 가능해진다. 그런데 컨테이너가 호스트의 파일 시스템을 마음대로 바꿔서 악의적인 행동을 하면 안되기 때문에 기본적인 권한이 매우 낮다. Dockerfile내에서 USER 인스트럭션을 활용하여 관리자 권한을 부여해줄 수 있다.

흥미로운 시나리오를 몇가지 살펴보자

- 이미 컨테이너 내에 /a라는 디렉토리가 존재하고 있었는데 바인드 마운트를 통해 로컬의 /hoho라는 디렉토리를 /a 디렉토리에 마운트해버리면 어떻게 될까?
  → 로컬의 /hoho 디렉토리가 완전 덮어 써버려서 기존의 이미지레이어에 붙어있던 데이터가 날아가버림
  그래서 기본적으로 바인드 마운트할때는 의도한게 아니라면 컨테이너 내에 새롭게 디렉토리를 만들고 연결해주는 느낌이라고 이해하면 됨
- 꼭 디렉토리가 아니고 단일 파일만도 마운트가 가능하다. 이미 컨테이너 내에 존재하는 디렉토리에 단일 파일만 바인드 마운트하면 어떻게 될까? → 이때는 둘다 남아있음

```docker
# bind mount 활용법
# --mount 옵션과 --volume 옵션이 거의 비슷한데 --volume은 예전에 많이 쓰던 옵션이고
# 요새는 --mount를 많이 쓴다고함. 공식 문서 읽어보니까 그냥 --mount쓰라고 하네요
# 이게 경로 연결할때 달라지면 안되니까 환경변수로 심어놓고 사용하는게 좋음
# 아래와 같이 환경변수를 임시로 저장해두고 $환경변수이름 으로 활용하면 됨
source="$(pwd)/hoho" && target='/data'

docker container run --mount type=bind,source=$source,target=$target [image Name]
```

### 연습문제

연습문제는 이미지 레이어에 기본 디렉토리가 박혀있는 이미지인데 마운트할때 설정파일을 바꿔버림으로써 약간 기본 행동옵션이 달라지게 조작해보는 연습이었음.

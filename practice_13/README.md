# 13강. 도커 스웜 스택으로 분산 애플리케이션 배포하기

지난 시간에는 직접 도커 스웜을 통해 커맨드라인에서 여러 명령을 사용하며 클러스터를 운영해보는 경험을 해봤음. 근데 실제 운영을 할때는 그렇게 CLI에 직접 명령을 내려서 운영하지 않는다고함. 도커 컴포즈에서 yml파일에 원하는 상태를 기술해서 적어주면 도커 컴포즈가 알아서 그 상태를 만족시켜줬던거처럼 도커 스웜에서도 yml 파일에 “원하는 상태”를 기술해서 적어주면 도커 스웜이 알아서 그걸 맞춰줄거임. 그래서 도커 컴포즈 파일 작성하듯이 yml파일을 작성해서 넘겨주는 방법을 배워 볼거임

### 도커 컴포즈를 사용한 운영 환경

도커 스웜은 컴포즈를 만날 때 진정한 위력을 발휘한다.  스웜에서 가장 간단한 배포는 컴포즈 파일 그 자체다.
도커 컴포즈에서와 비슷하게 스웜에서도 동일한 Yml 파일을 활용해 애플리케이션을 배포할 수 있음.
배포가 끝나면 레플리카를 실행하는 서비스가 생성되고, 이 서비스는 인그레스 네트워크를 통해 포트를 공개하고 있을거임.  스웜 모드에서는 애플리케이션을 배포할 때 “스택”을 만듬. 스택이란 서비스, 네트워크, 볼륨 등 여러 개의 도커 리소스를 묶어 만든 리소스를 말함

```docker
# 컴포즈 파일로 스택을 배포
docker stack deploy -c v1.yml test

# 스택 목록에서 새로 생성된 스택 확인
docker stack ls
# 스택에 생성된 서비스 목록확인
docker stack services [스택이름]
#스택에 실행중인 레플리카 목록확인
docker stack ps [스택이름]

# 서비스 목록에서 새롭게 생성된 서비스 확인
docker service ls
```

스웜 모드에서는 일반 모드에서는 없던 추가 기능이 있음. yml 파일 정의시 deploy 프로퍼티를 추가해줄 수 있는데, 이 부분에 레플리카의 수라든지, 해당 레플리카가 호스트 노드의 CPU와 메모리를 얼마만큼만 사용할 수 있을지를 지정해줄 수 있음.  도커 컨테이너는 따로 지정하지 않는 이상 기본적으로 호스트 컴퓨터의 CPU와 메모리를 무제한으로 사용할 수 있음. 그래서 버그나 악의적인 사용자에 의한 문제를 막기위해 상한선을 걸어주는건 실제 운영시에 꼭 필요한 작업임. 

```docker
services:
  logger:
    image: diamol/ch09-access-log
    deploy:
      replicas: 3
      resources:
        limits:
            cpus: "0.20"
            memory: 100M
    networks:
      - lab-net

#### 업데이트 사항 스택에 반영해주기
docker stack deploy -c v2.yml test

# 스택 제거하기 
docker stack rm test
```

스택 제거시 스택에 속한 모든 리소스(서비스, 네트워크, 볼륨 등등) 이 모두 함께 사라짐. 
이렇게 사라지는것을 막고 싶다면 yml파일을 통해 자동으로 생성되게 하지말고 별도로 네트워크나 볼륨을 생성해주어야함. 

### 컨피그 객체를 이용한 설정값 관리

이전에는 환경변수를 넘겨준다든지 파일을 넘겨주는 방식으로 설정값을 넘겨주었음. 
이번에는 클러스터에 저장되는 도커 컨피그(docker config) 객체를 이용해 운영 환경에서 애플리케이션에 설정값을 제공하는 방법을 알아보자. 

스웜에서는 설정값을 위해 도커 컨피그 객체가 사용됨. 컨피그 객체는 컨테이너가 설정값을 클러스터에서 읽어 올 수 있게 해주는 강력한 기능을 가진 리소스이자 애플리케이션 배포와 설정 관리를 분리해주는 역할을 함

```docker
# 로컬에 위치한 JSON 파일로 컨피그 객체 생성
docker config create my_config ./configs/config.json

# 컨피그 객체의 목록 조회
docker config ls

# 컨피그 객체의 세부사항 출력. --pretty 옵션을 넣으면 사람이 읽기 좋게 나옴
docker config inspect --pretty my_config
```

컨피그 객체도 다른 도커 리소스와 사용 방법이 같음. 커맨드 라인 상에서 생성, 삭제, 확인이 모두 가능함. 
위의 inspect 명령을 통해 출력해보면 알겠지만 컨피그 객체를 확인하면 설정파일의 내용을 그대로 볼 수 있음. 
이게 의미하는 바는 컨피그 객체는 민감한 데이터를 보관하기 위한 수단이 아니라는 점임!!

이걸 실제 활용하는 방법은 다음과 같음. 이렇게 함으로써 설정값 배포와 애플리케이션 배포를 분리할 수 있음. 

1.  먼저 컨피그 객체를 만들어서 생성해둔다
2. yml 파일에서 생성해둔 컨피그 객체를 참조하도록 한다. 

```docker
services:
  todo-web:
    image: diamol/ch06-todo-list
    ports:
      - 8080:80
    configs:
      - source: todo-list-config
        target: /app/config/config.json

configs:
  todo-list-config:
    external: true 

#external: true의 의미는 이미 밖에 만들어져있다는 소리임.
#수정사항을 반영해서 다시 배포하려면 역시 deploy 명령을 쓰면 됨
docker deploy -c v3.yml [스택이름]
```

### 비밀값을 이용한 대외비 설정 정보 관리하기

앞에서 컨피그에는 민감한 정보를 담으면 안된다고 배웠음. 그래서 민감한 정보를 담을때는 컨피그가 아닌 비밀값 (docker secret)을 활용해야함. 시크릿이랑 컨피그랑 생성하고 사용하는 방식이 거의 비슷함. 유일하게 다른점은 시크릿의 경우 컨테이너 안에 전달되어서 실제 사용될때만 복호화되어있고 나머지 상황에는 항상 암호화되어있어서 노출되지 않는다는 점임. 

```docker
# 로컬에 위치한 JSON 파일의 내용으로 비밀값 생성
docker secret create my-secret ./secrets/secrets.json

# 비밀값 내용 출력하기. 메타데이터밖에 안나오는걸 확인할 수 있음
docker secret inspect --pretty my-sercret

# yml 파일 활용예시
services:
  todo-web:
    image: diamol/ch06-todo-list
    secrets:
      - source: todo-list-secret
        target: /app/config/secrets.json

secrets:
  todo-list-secret:
    external: true
# 마찬가지로 external: true는 외부에 이미 생성되어져있다는 의미임.
```

한가지 알아두어야할 점은 컨피그나 시크릿은 수정이 불가능하다는 점임. 그래서 수정을 하려면 새로 만들고 새로 만든 값을 사용하도록 yml 파일의 설정을 바꿔주어야함. 

1. 변경된 내용을 담은 새로운 컨피그 객체 혹은 비밀값을 기존의 것과 다른 이름으로 만든다
2. 컴포즈 파일의 정의에 사용된 컨피그 객체 혹은 비밀값의 이름을 새로 만든 이름으로 바꾼다
3. 변경된 컴포즈 파일로 스택을 배포한다 

→ 서비스를 업데이트하는 일을 너무 두려워하지 말자. 아무리 안해도 의존 모듈이나 기반 이미지에 새로 나온 보안 업데이트를 적용하려면 한달에 최소 한번은 해야한다고 함.

### 스웜에서 볼륨 사용하기

스웜을 사용할때 제일 궁금했던게 여러곳에 분산되어서 작동하면 디비는 어떻게하지라는 의문이었음. 이 부분이 완전한 답은 아니지만 일부의 답은 해주는 것 같음. 

오케스트레이션 플랫폼에서도 볼륨의 개념은 같음. yml 파일의 서비스 정의에 볼륨 마운트를 정의하면, 레플리카에서 볼륨을 로컬 파일 시스템의 디렉터리처럼 사용할 수 있음. 하지만 데이터가 저장되는 방식에 차이가 있음. 

애플리케이션을 의도대로 동작하게 하려면 이 차이를 잘 이해해야 함.
클러스터를 여러개의 노드로 구성하고, 이들 노드는 각각 디스크가 있어서 자신의 디스크에 로컬 볼륨을 저장함. 
업데이트 이후에도 데이터를 유지하는 가장 간단한 방법은 새로 생성된 레플리카가 이전 레플리카가 사용하던 로컬 볼륨을 그대로 사용하도록 하는 것임.  그런데 한가지 치명적인 문제상황이 있음. 

어떤 레플리카의 대체로 새롭게 생성된 레플리카가 반드시 같은 노드에 생성된다는 보장이 없음. 다른 노드에 생성된다면 로컬 볼륨에 접근할 수가 없어서 위의 방법으로는 해결하지 못함. 
책에서는 이런 상황에 대해 특정 서비스는 특정 노드에서만 실행되도록 지정함으로써 문제를 해결하고 있음. 
즉, 특정 노드에 레이블을 부여하고 yml 파일에서 특정 서비스는 특정 레이블이 달린 노드에서만 실행되도록 설정을 추가함으로써 해결 가능함. 

```docker
# 노드의 식별자를 찾아 해당 노드에 레이블을 부여
# 레이블은 키=값 형식으로 들어감. 아래의 예시는 storage라는 키에 raid라는 값이 들어가는거임.
docker node update --label-add storage=raid $(docker node ls -q)

# 중요한 사실은 이제 노드를 구분할 수 있는 방법이 생겼다는 점임
# 실제 yml 파일에서의 활용은 deploy 프로퍼티 부분에 constraints를 추가함으로써 가능함

todo-db:
    image: diamol/postgres:11.5
    environment:
      PGDATA: "/var/lib/postgresql/data/pgdata"
    volumes:
      - todo-db-data:/var/lib/postgresql/data
    deploy:
      replicas: 1
      resources:
        limits:
          cpus: "0.50"
          memory: 500M
      placement:
        constraints:
          - node.labels.storage == raid
    networks:
      - app-net

volumes:
  todo-db-data:
```

위의 코드를 보면 volumes 부분이 뭔가 빠져있는거 같은데 코드가 생략된것은 아님.
저렇게 적어주면 스웜의 기본 볼륨 드라이버를 사용해 로컬 디스크 볼륨을 생성해줌. 이 정의대로 스택에 배포하면 라벨이 붙은 노드에는 todo-db-data라는 이름으로 로컬 볼륨이 생성되고 데이터가 저장됨. 

볼륨과 관련해서 조금 조심해야할 부분이 있음. 
이미지를 생성할때 Dockerfile 스크립트에 볼륨을 지정할 수 있는데, 이렇게 볼륨이 사용된 이미지를 서비스에서 사용하면 해당 스택에는 서비스에서 사용할 기본 볼륨이 자동으로 생성됨. 그런데 이 기본 볼륨은 서비스가 내려가면 사라져버림. 업데이트 이후에도 데이터를 유지하려면 위의 예시에서와 같이 컴포즈 파일에서 이름을 부여한 볼륨을 사용해야 함. 이렇게 생성된 볼륨의 경우 스택을 제거하더라도 라벨이 붙은 노드가 사라지지 않는 이상 데이터를 유실하지 않음. 즉 컨테이너 교체에도 안전하다는 의미임. 

다만 위의 방법은 내 생각에는 반쪽짜리 해결법인거 같음. 로컬 볼륨을 사용하도록 강제한다고 하더라도 노드 간에 분산되어 있는 데이터베이스라면 데이터 동기화나 그런게 없으니까 ㅇㅇ.. 이런 부분은 디비 클러스터부분에서 어떻게 처리하는지 좀 알아봐야할듯.

### 클러스터는 스택을 어떻게 관리하는가?

도커 스웜에서 말하는 스택은 클러스터가 관리를 담당하는 리소스의 모임임. 

- 볼륨
    - 스웜도 볼륨을 생성하고 삭제할 수 있음.
    - 서비스 이미지에 볼륨의 정의가 포함된 경우 스택에 기본 볼륨을 생성하지만, 스택을 제거하면 같이 제거
    - 스택 정의에 이름이 붙은 볼륨을 사용하면(yml 파일에 따로 만들면) 스택 배포와 함께 볼륨이 생성되지만, 이 볼륨은 스택이 제거되더라도 삭제되지 않음
- 비밀값과 컨피그 객체
    - 설정값이 든 파일을 클러스터에 업데이트하는 방법으로 생성
    - 클러스터 데이터베이스에 저장됐다가 이들을 사용하는 컨테이너가 실행될때 해당 컨테이너로 전달됨.
    - 비밀값과 컨피그 객체는 전형적인 읽기 전용 객체로 수정이 불가능함.
    - 스웜 환경에서 애플리케이션 설정값 관리는 배포 프로세스와 별도임
- 네트워크
    - 애플리케이션과 별도로 관리됨
    - 관리자가 명시적으로 네트워크를 생성할 수도 있고, 필요시 스웜이 네트워크를 생성하기도 함.
    - 모든 스택은 컴포즈 파일에 네트워크가 정의되어 있지 않더라도 자신이 포함한 서비스를 연결할 네트워크와 함께 배포됨.
- 서비스
    - 서비스는 스택이 배포될때 생성되고 제거될때 같이 제거됨.
    - 서비스 실행중에는 스웜이 서비스를 모니터링하며 서비스 수준이 정상치를 유지하는지 체크
    - 이상이 발견된 컨테이너는 새로운 컨테이너로 교체됨

스택은 애플리케이션을 구성하는 요소를 모아 놓은 논리적 객체임
하지만 스택에는 서비스 간의 의존 관계를 정의하는 기능이 없음. 달리 말하면 어떤 서비스가 완전히 실행된 다음에 다른 서비스를 실행하도록 강제할 방법이 없음. 그렇기 때문에 개발자는 각 애플리케이션 컴포넌트가 무작위 순서로 실행된다고 생각해야함. 이미지 생성시 이전에 다뤘던 헬스 체크와 디펜던시 체크를 추가해두어 정상 작동이 아닌경우 종료하게 하면, 컨테이너를 재시작 or 대체함으로써 문제를 해결할 수 있음. 이게 바로 self healing이 가능한 애플리케이션임
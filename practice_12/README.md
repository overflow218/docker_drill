# 12강. 컨테이너 오케스트레이션: 도커 스웜과 쿠버네티스

지금까지는 하나의 로컬 머신에서 도커를 활용하는 것을 연습해봤음. 근데 실제 서비스를 운영할때는 성능상의 이유로 여러 컴퓨터에서 서비스를 실행함. 즉 여러 대의 도커 호스트에서 컨테이너를 실행하게 됨. 이런 상황에서 관리를 위한 도구가 필요한데 이러한 관리 레이어를 오케스트레이션(orchestration)이라고 부름. 

대표적인 오케스트레이션 도구로 도커 스웜(Docker swarm)과 쿠버네티스(kubernetes)가 있는데 쿠버네티스는 책을 따로 하나 봐야할만큼 기능이 많고 강력함. 도커 스웜은 상대적으로 간단하지만 이걸 배워두면 쿠버네티스 배우기도 훨씬 수월하다고 하니 이번기회에 잘 알아두도록 하자.

### 컨테이너 오케스트레이션 도구란?

서비스 운영을 위한 시스템은 고가용성을 요구하는데, 이 때문에 오케스트레이션이 꼭 필요함. 

> 오케스트레이션 도구란 기본적으로 클러스터를 구성하는 여러 대의 호스트 컴퓨터를 의미. 
오케스트레이션 도구는 컨테이너를 관리하고, 서비스를 제공하기 위한 작업을 여러 컴퓨터에 분배하며, 네트워크 트래픽을 고르게 분산시키고, 상태가 불량한 컨테이너를 새 컨테이너로 교체하는 일을 담당함.
> 

복잡한 컨테이너 관리는 모두 오케스트레이션 도구가 대신해줌. 우리는 원하는 애플리케이션의 상태만 YAML 파일에 작성해서 넘겨주면 됨. 어떤 서버에서 몇개의 컨테이너를 실행할지, 죽은 컨테이너는 어떻게 다시 실행시킬지 등등은 다 오케스트레이션 도구가 책임지고 해결해줌. 진짜 엄청난 기술인거 같음

클러스터는 1000대의 호스트일 수도 있고, 단일 호스트일 수도 있음. 중요한 건 호스트 대수와 상관없이 똑같은 명령을 사용하고 YAML 파일을 전달해 애플리케이션을 배포한다는 점임. 

### 도커 스웜으로 클러스터 만들기

```docker
# 1. 일단 도커 엔진을 스웜모드로 전환해야함. 
docker swarm init

# 워커 노드로 스웜에 참여하기 위한 명령 출력
docker swarm join-token worker
# 매니저 노드로 스웜에 참여하기 위한 명령 출력
docker swarm join-token manager

# 스웜에 참여 중인 노드의 목록을 출력
docker node ls

# 더 다양한 명령어
docker swarm --help
```

일단 용어를 명확히 하고 갈 필요가 있음. 

- 클러스터 → 여러 노드가 묶여서 형성하는 가용한 서버 그룹이라고 생각하면 됨
- 노드 → 클러스터에 속한 각 호스트 하나 하나를 의미함

노드는 스웜에 매니저 혹은 워커로 참여할 수 있음. 

- 매니저 노드
    - 클러스터를 관리하는 작업을 직접 수행함.
    - 클러스터 데이터베이스도 매니저 노드에 저장됨
    - 사용자가 YAML 파일 전달을 위해 사용하는 API도 매니저 노드에서 동작
    - 컨테이너 모니터링과 스케줄링 모두 매니저 노드가 수행
    - 워커의 역할도 할 수 있음
- 워커 노드
    - 매니저의 스케줄링에 따라 컨테이너를 실행
    - 컨테이너의 상태를 주기적으로 매니저에 보고

위의 Join-token 명령을 실행하면 참여할 수 있는 토큰과 함께 docker swarm join ~~~~ 값을 전달해줌. 이거를 이제 참여하려는 노드에서 실행해주면 됨. 다만 같은 네트워크에 속한 노드만 참여할 수 있음. 

다른 컴퓨터가 더 없다면 단일 노드 스웜을 실행하고 있는 상황임. 노드가 여러개인 스웜이랑 할 수 있는 명령어같은건 다 똑같음. 다만 가용성이 좀 떨어지고 컨테이너 생성에 한계가 있다는 정도가 다름

도커 스웜이 쿠버네티스보다 나은 점 중에 하나가 클러스터를 구성하고 관리하는 작업이 쉽다는 점임. 수십대 정도 규모의 클러스터라면 그냥 docker swarm init 명령 한번 실행하고, 나머지 노드에서 join 명령 한번씩만 실행해주면 됨. 

### 도커 스웜 서비스로 애플리케이션 실행하기

이전에 그냥 도커를 사용할때는 컨테이너를 주로 실행했다면 스웜 모드에서는 기본이 서비스를 실행한다고 생각하면 됨. 서비스는 컨테이너랑 굉장히 유사한데(실제로 생성할때 넘겨주는 인자도 거의 비슷함) 여러 개의 레플리카를 가질 수 있다는 점이 다름. 그니까 쉽게 말해서 여러 노드에 분산되어서 실행되는 레플리카들의 뼈대, 붕어빵 찍는 빵틀같은게 서비스라고 생각하면 됨. 

여기서 레플리카라는 개념이 등장하는데 레플리카는 “서비스와 똑같이 설정되지만 스웜상의 여러 노드에 흩어져 배치되어 실행되는 컨테이너”를 의미함. 

```docker
# 새로운 서비스를 생성. 
# 참고로 서비스를 다루려면 도커 엔진이 스웜모드이거나 스웜 매니저에 연결된 상황이어야함
docker service create --name timecheck --replicas 3 diamol/ch12-timecheck:1.0

# 실행중인 서비스 목록 출력
docker service ls

# 특정 서비스의 레플리카 목록 출력
docker service ps [service 이름]

# 특정 서비스의 로그 정보 출력
# 서비스는 여러개의 레플리카로 이루어지는데 각 레플리카에서 생성된 로그를 
# 스웜이 모아서 보여줌. 어떤 레플리카에서 온건지 정보가 다 달려있음
docker service logs --since 10s [service 이름]

# 서비스의 정보 중 이미지 정보를 출력
docker service inspect [service 이름] -f '{{.Spec.TaskTemplate.ContainerSpec.Image}}'

# 서비스의 내용을 수정
# docker service update --help 명령을 통해 사용가능한 필드명을 더 많이 볼 수 있음.
docker service update --image diamol/ch12-timecheck:2.0 timecheck

# 서비스 내용을 롤백
# 애플리케이션의 이전상태를 도커 스웜에서 저장하고 있기때문에 문제 없음
docker service udpate --rollback timecheck
```

일부러 서비스의 컨테이너를 죽인다든지, 서비스의 내용을 수정하면 도커 스웜이 알아서 설정한 레플리카 개수에 맞게 다시 레플리카를 실행한다든지 수정된 버전으로 레플리카를 올려줌. 도커 스웜의 기본적인 업데이트 전략은 롤링 업데이트임. 롤링 업데이트는 구, 신버전이 모두 실행되는 상황에서 업데이트를 진행하는걸 말함. 
요 상황에서는 어디로 요청이 갈지 모르기때문에 UX관련 부분은 전략을 서비스단에서 해결해줘야함. 

### 클러스터 환경에서 네트워크 트래픽 관리하기

이전까지 컨테이너 간의 통신을 돕기위해 도커 네트워크 기능을 활용했음. 클러스터 내에서의 통신을 위해서 스웜 모드에서는 오버레이 네트워크(overlay network)라는 새로운 형태의 도커 네트워크를 지원함. 
오버레이 네트워크는 클러스터에 속한 모든 노드를 연결하는 가상 네트워크임. 오버레이 네트워크에 연결된 서비스는 서비스 이름을 도메인 삼아 다른 서비스와 통신할 수 있음. 이때 오버레이 네트워크는 서로 독립적이기때문에 서로 다른 오버레이 네트워크에 속한 서비스들간에는 통신이 불가능함.

오버레이 네트워크랑 일반적인 도커 네트워크와의 차이점이 한가지 있음. 일전에 도커 컴포즈 활용해서 하나의 서비스를 여러 컨테이너로 스케일링하는 방법을 배워본적이 있음. 이때 서비스에 대한 DNS 질의를 하면 모든 컨테이너의 IP 주소가 응답에 포함됐음. 반면에 오버레이 네트워크에서는 서비스를 가르키는 가상의 IP 주소 하나만이 반환됨. 

```docker
# overlay 네트워크 생성
# 스웜모드에서 네트워크 생성시 디폴트가 오버레이 타입이긴하지만 이렇게 명시적으로 넣어주는 습관을 가지자!
docker network create --driver overlay iotd-net

# overlay network로 네트워크 달아서 서비스 실행해주기
docker service create --detach --replicas 3 --network iotd-net --name iotd1 image1
docker service create --detach --replicas 3 --network iotd-net --name iotd2 image2

# 최근에 생성한 컨테이너 접속
docker exec -it $(docker ps --last 1 -q) sh 
# DNS 조회하기
nslookup iotd1
nslookup iotd2
```

도커 스웜은 서비스 접근에 대한 신뢰성을 높이고 부하를 잘 분산시키기 위해 VIP 네트워크를 사용함. 
서비스 간 통신 문제를 디버깅할때는 이점을 잘 기억해야함. 그렇지 않으면 DNS 조회시 IP주소가 하나만 나오는거 보고 당황할 수 있음. 이러한 네트워크의 동작은 클러스터를 스케일링하거나 애플리케이션을 스케일링하게 되면 훨씬 더 복잡해짐. 

예를 들어 10개의 레플리카로 실행되는 애플리케이션이 있는데, 클러스터의 노드가 20개라면 레플리카를 실행중이지 않은 노드들도 있는 상황임. 반대로 노드는 5개인데 20개의 레플리카가 실행중이라면 1개 이상의 레플리카를 실행중인 노드가 있는 상황임. 이런 상황에서의 로드 밸런싱이나 작동중이지 않은 노드로 전달된 요청을 처리하는게 상당히 문제인데 스웜은 인그레스 네트워킹 (ingress networking)을 통해 이를 해결해줌!

도커 공식 사이트에 검색해보니까 routing mesh 라고도 부르는 방법인거 같음. 

[Use swarm mode routing mesh](https://docs.docker.com/engine/swarm/ingress/)

간단하게 이해한걸 적어보면 각 노드별로 스웜 로드밸런서가 붙어있는데 각 로드밸런서는 다른 모든 레플리카와 연결되어 있음. 그래서 요청을 받은 노드에 실행중인 레플리카가 없더라도 적절한 레플리카로 포워딩해주는게 가능함. 그리고 각 서비스 만들때 포트 바인딩을 해줄수 있는데 그건 ingress 네트워크의 해당 포트로 들어온 내용을 각 노드로 전달해줌. 그래서 8080:80 이런식으로 공개했다면 인그레스 네트워크 8080으로 들어온 내용을 각 노드로 전달해서 각 노드의 해당하는 레플리카의 80번으로 전달되어 들어가는 거임. 이때 꼭 각 노드가 8080번 포트를 할당해놓을 필요없이 앞단에서 묶어서 처리해준다고 함. 진짜 미쳤다 미쳤어

### 도커 스웜과 쿠버네티스 중 무엇을 사용할까?

도커스웜

- 상대적으로 기능이 간단함
- 매니지드 서비스 형태로 지원하는 클라우드 사업자가 아직 없음 → 쓰려면 직접 세팅해야함.

쿠버네티스

- 주요 클라우드 서비스에서 매니지드 서비스 형태로 제공되기때문에 지명도가 더 높음
- 확장성이 아주 뛰어나서 클라우드 사업자가 로드 밸런서, 스토리지 등과 같은 애플리케이션 배포를 지원하는 자사 프로덕트와 통합하기가 유리함

몇가지 고려 포인트

- 인프라스트럭쳐 - 클라우드 환경을 사용중이라면 쿠버네티스, 온프레미스 환경이라면 도커 스웜이 관리면에서 훨씬 간편.
- 학습 곡선 → 도커와 도커 컴포즈를 안다면 도커 스웜쓰는게 훨씬 쉬움. 쿠버네티스는 어려움
- 기능 → 쿠버네티스 압승. 블루-그린 배포(blue-grenn deployment)나 자동 스케일링, 역할 기반 접근 제어 등등… 도커 스웜에 적용하기엔 어려움
- 미래를 위한 투자 → 쿠버네티스의 오픈 소스 커뮤니티는 매우 활동적이고 규모도 업계 최대임. 도커 스웜은 …

결론: 최종적으로는 쿠버네티스 써야하긴함. 다만 당장 쿠버네티스의 기능이 필요한게 아니라면 도커 스웜도 좋은 선택지라고함.